#' CV multivariate PLS (comparable to cv_unique_auc_par) using AUC.
#'
#' @param X a number-of-observations times nodes matrix.
#' @param Y a number-of-observations times reponses matrix (only 0s and 1s).
#' @param ncomp number of components, integer.
#' @param center center the data.
#' @param folds a user defined list of folds (as generated by
#' caret::createFolds()) or an integer indicating the number of folds.
#' Independent of fdaPDE::FPCA.FEM's validation.
#' @param verbose logical, indicating if messages should be printed.
#'
#' @return A list of crossvalidates erros (CVEs).
#' @export
#'
#' @examples
#' # 1D example:
#'
#' # library(pls)
#' # library(fda)
#'
#' # Octane number:
#' Y <- as.matrix(pls::gasoline$octane)
#' Y <- ifelse(Y > 87, 1, 0)
#'
#' # Gasoline NIR spectra:
#' X <- as.matrix( as.data.frame( pls::gasoline$NIR ) )
#'
#' cv_mv <- cv_auc_mvpls(X = X, Y = Y, ncomp = 5, folds = 5, center = TRUE,
#'                   verbose = FALSE)
cv_auc_mvpls <- function(X,
                         Y,
                         ncomp = min(10, ncol(X)),
                         center = TRUE,
                         folds = 5,
                         verbose = TRUE) {

  tictoc::tic("Crossvalidation")

  # Check if Y is not multivariate:
  if (ncol(Y) > 1) {
    cat("This crossvalidation cannot process a multivariate response.\n")
  }


  # Recode as proportions
  Y01 <- Y # save original binary var.
  # proportions:
  p0 <- sum(Y01 == 0)/nrow(Y01)
  p1 <- sum(Y01 == 1)/nrow(Y01)
  # response var. with proportions (input for PLS):
  Y <- Y01
  Y[Y01 == 1] <- -sqrt(p0/p1) # Positive
  Y[Y01 == 0] <- sqrt(p1/p0) # Control



  if (is.numeric(folds)) {

    num_folds <- folds
    folds <- caret::createFolds(Y, k = num_folds)

  }else if (is.list(folds)) {

    num_folds <- length(folds)

  }

  # Initialize AUCs:
  AUC_ncomp_fold <- matrix(data = NA,
                           nrow = ncomp,
                           ncol = num_folds) # MSE per component per fold
  colnames(AUC_ncomp_fold) <- paste0("fold_", 1:num_folds)
  rownames(AUC_ncomp_fold) <- paste0("ncomp_", 1:ncomp)


  for (ncomp_i in 1:ncomp) {

    if (verbose) {
      cat("Component ", ncomp_i, "/", ncomp, "\n")
    }


    for (i in 1:num_folds) {

      if(verbose){
        cat("  Fold ", i, "/", num_folds, "\n")}

      # build train
      Y_fold_train <- Y[-folds[[i]], , drop = F]
      X_fold_train <- X[-folds[[i]], , drop = F]

      # build test:
      Y_fold_test <- Y[folds[[i]], , drop = F]
      Y01_fold_test <- Y01[folds[[i]], , drop = F] # to be used in AUC
      X_fold_test <- X[folds[[i]], , drop = F]

      # PLS model:
      pls_res <- pls::plsr(Y_fold_train ~ X_fold_train,
                           ncomp =  ncomp_i,
                           model = "oscorespls",
                           center = center,
                           scale = FALSE)

      Yhat_fold_test <- stats::predict(object = pls_res, newdata = X_fold_test, ncomp = ncomp_i)

      roc_object <- pROC::roc( as.numeric(Y01_fold_test), as.numeric(Yhat_fold_test),
                               quiet = !verbose)

      # save AUC:
      AUC_ncomp_fold[ncomp_i, i] <- as.numeric( pROC::auc( roc_object) )


    } # end k-fold


  } # loop in ncomp: number of components

  # Save the folds-averaged AUCs:
  AUCs_ncomp <- rowMeans(AUC_ncomp_fold)
  names(AUCs_ncomp) <- paste0("ncomp_", 1:ncomp)

  if (verbose) {
    cat("Fitting final model\n")
  }

  final_model <- pls::plsr(Y ~ X,
                           ncomp =  ncomp,
                           method = "oscorespls",
                           center = TRUE,
                           scale = FALSE )

  ret <- list(AUCs_ncomp = AUCs_ncomp,
              AUC_ncomp_fold = AUC_ncomp_fold,
              final_model = final_model,
              elapsed = tictoc::toc(quiet = !verbose)    )

  return(ret)

}
