#' Sequential crossvalidation in parallel (different penalty for each component) using AUC.
#'
#' @param X a number-of-observations times nodes matrix.
#' @param Y a number-of-observations times reponses matrix (only 0s and 1s).
#' @param center logical, indicating if data should be centered.
#' @param argvals a set of argument values. Not needed for FEM basis.
#' @param nodes a 2-column matrix with the nodes. Needed for "fpls_tps".
#' @param nbasis number of TPS basis to use in method "fpls_tps".
#' @param penalty_vec a vector of possible penalties.
#' @param ncomp number of components, integer.
#' @param folds a user defined list of folds (as generated by caret::createFolds())
#' or an integer indicating the number of folds.
#' @param basisobj a Finite Elements basis as in the fdaPDE package.
#' @param R0 (mass) matrix of inner products between TPS basis functions.
#' @param P penalty matrix (optional for method "fpls_tps").
#' @param method only supported by: "r1fpls_fem".
#' @param tol convergence tolerance.
#' @param verbose logical, indicating if messages should be printed.
#' @param stripped logical.  If \code{TRUE} the calculations are stripped as
#' much as possible for speed. Particularly, if \code{FALSE} (default) it computes
#' the final models using the best combination of penalties.
#' Inspired by package \code{pls}.
#'
#' @return A list of crossvalidates erros (CVEs) and penalties giving the minimum
#' CVEs per number of components.
#' @export
#'
#' @importFrom foreach %dopar%
#' @importFrom foreach %:%
#'
#' @examples
#' # 1D example:
#'
#' # library(pls)
#' # library(fda)
#'
#' # Octane number:
#' Y <- as.matrix(pls::gasoline$octane)
#' Y <- ifelse(Y > 87, 1, 0)
#'
#' # Gasoline NIR spectra:
#' X <- as.matrix( as.data.frame( pls::gasoline$NIR ) )
#'
#' # Wavenumber:
#' argvals <- seq(900, 1700, by = 2)
#'
#' # Ruppert's law:  nbasis = nbreaks + norder - 2  and norder = degree + 1
#' n_breaks <- min(round(length(argvals)/4), 40)
#' n_basis <- n_breaks + (3+1) - 2
#'
#' # B-spline basis:
#' bs_basis <- fda::create.bspline.basis(rangeval = range(argvals),
#'                                  nbasis = n_basis)
#'
#' cv_ps <- cv_seq_auc_par(X = X, Y = Y, argvals = argvals, penalty_vec = c(0.01, 10, 100),
#'                  ncomp = 3, folds = 5, basisobj = bs_basis, method = "fpls_bs",
#'                  verbose = FALSE, stripped = FALSE)
#'
#' final_ps <-cv_ps$final_model
cv_seq_auc_par <- function(X,
                       Y,
                       center = TRUE,
                       argvals = NULL,
                       nodes = NULL,
                       nbasis = NULL,
                       penalty_vec,
                       ncomp = min(10, ncol(X)),
                       folds = 5,
                       basisobj = NULL,
                       R0 = NULL,
                       P = NULL,
                       method = NULL,
                       tol = .Machine$double.eps^0.5,
                       verbose = TRUE,
                       stripped = TRUE ) {

  tictoc::tic("Crossvalidation")

  # Check if Y is not multivariate:
  if (ncol(Y) > 1) {
    cat("This crossvalidation cannot process a multivariate response.\n")
  }


  # Initialize grid for the first component
  penalty_grid <- matrix(penalty_vec)
  colnames(penalty_grid) <- "ncomp_1"

  if (is.numeric(folds)) {

    num_folds <- folds
    folds <- caret::createFolds(Y, k = num_folds)

  }else if (is.list(folds)) {

    num_folds <- length(folds)

  }

  # Initialize CVEs:
  AUCs_ncomp <- array(data = NA, dim = ncomp) # averaged
  names(AUCs_ncomp) <- paste0("ncomp_", 1:ncomp)

  AUC_ncomp_fold <- matrix(data = NA,
                           nrow = ncomp,
                           ncol = num_folds) # MSE per component per fold
  colnames(AUC_ncomp_fold) <- paste0("fold_", 1:num_folds)
  rownames(AUC_ncomp_fold) <- paste0("ncomp_", 1:ncomp)


  # Recode as proportions
  Y01 <- Y # save original binary var.
  # proportions:
  p0 <- sum(Y01 == 0)/nrow(Y01)
  p1 <- sum(Y01 == 1)/nrow(Y01)
  # response var. with proportions (input for PLS):
  Y <- Y01
  Y[Y01 == 1] <- -sqrt(p0/p1) # Positive
  Y[Y01 == 0] <- sqrt(p1/p0) # Control


  for (ncomp_i in 1:ncomp) {

    if (verbose) {
      cat("Component ", ncomp_i, "/", ncomp, "\n")
    }

    i <- row_lambda <- NULL

    AUC_lambda_fold <-
      foreach::foreach (i = 1:num_folds,
                        .packages = c("pROC", "penR1FPLS"),
                        .combine = "cbind") %:%
      foreach::foreach(row_lambda = 1:nrow(penalty_grid),
                       .packages = c("pROC", "penR1FPLS"),
                       .combine = 'c' ) %dopar%
      {

        # build train
        Y_fold_train <- Y[-folds[[i]], , drop = F]
        X_fold_train <- X[-folds[[i]], , drop = F]

        # build test:
        Y_fold_test <- Y[folds[[i]], , drop = F]
        Y01_fold_test <- Y01[folds[[i]], , drop = F] # to be used in AUC
        X_fold_test <- X[folds[[i]], , drop = F]

        res_fpls <- sofr(X = X_fold_train,
                         Y = Y_fold_train,
                         argvals = argvals,
                         nodes = nodes,
                         nbasis = nbasis,
                         ncomp = ncomp_i,
                         center = center,
                         basisobj = basisobj,
                         R0 = R0,
                         P = P,
                         method = method,
                         penalty = as.numeric(penalty_grid[row_lambda, ]),
                         tol = tol,
                         verbose = FALSE,
                         stripped = stripped )


        Yhat_fold_test <- stats::predict(object = res_fpls, newdata = X_fold_test)

        roc_object <- pROC::roc( as.numeric(Y01_fold_test), as.numeric(Yhat_fold_test[, , ncomp_i]),
                                 quiet = !verbose)

        # save AUC:
        as.numeric( pROC::auc( roc_object) )


      } # nested loop


    # Averaged AUC_lambda_fold per fold (giving mean AUC per lambda combination):
    AUC_ncomp_lambda <- rowMeans(AUC_lambda_fold)

    # Best penalties per component:
    sel_lambda <- which.max(AUC_ncomp_lambda)

    best_penalties <- penalty_grid[sel_lambda, , drop = F]

    if (ncomp_i < ncomp) {

      grid_names <- c(colnames(best_penalties), paste0("ncomp_", ncomp_i+1))

      penalty_grid <- data.frame(best_penalties,
                                 penalty_vec, row.names = NULL)

      colnames(penalty_grid) <- grid_names
    }


    # Save the folds-averaged AUC:
    AUCs_ncomp[ncomp_i] <- AUC_ncomp_lambda[sel_lambda]

    # Save AUCs per fold, for the best lambda:
    AUC_ncomp_fold[ncomp_i, ] <- AUC_lambda_fold[sel_lambda, ]

  } # loop in ncomp: number of components


  names(AUCs_ncomp) <- paste0("ncomp_", 1:ncomp)
  names(best_penalties) <- paste0("ncomp_", 1:ncomp)
  colnames(AUC_ncomp_fold) <- paste0("fold_", 1:num_folds)
  rownames(AUC_ncomp_fold) <- paste0("ncomp_", 1:ncomp)


  if (stripped) {
    ret <- list(
      AUCs_ncomp = AUCs_ncomp,
      AUC_ncomp_fold = AUC_ncomp_fold,
      best_penalties = best_penalties,
      elapsed = tictoc::toc(quiet = !verbose)
    )
  }else {

    if (verbose) {
      cat("Fitting final model\n")
    }

    final_model <- sofr(X = X,
                        Y = Y,
                        argvals = argvals,
                        nodes = nodes,
                        nbasis = nbasis,
                        ncomp = ncomp,
                        center = center,
                        basisobj = basisobj,
                        R0 = R0,
                        P = P,
                        method = method,
                        penalty = as.numeric(best_penalties),
                        tol = tol,
                        verbose = verbose,
                        stripped = stripped )

    ret <- list(
      AUCs_ncomp = AUCs_ncomp,
      AUC_ncomp_fold = AUC_ncomp_fold,
      best_penalties = best_penalties,
      final_model = final_model,
      elapsed = tictoc::toc(quiet = !verbose)
    )

  }



  return(ret)


}
